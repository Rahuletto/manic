import { green, red, dim, bold, cyan, yellow } from "colorette";
import { existsSync } from "node:fs";
import { loadConfig } from "../../config";
import { build } from "./build";

export async function deploy() {
  const config = await loadConfig();
  const providers = config.providers ?? [];

  if (providers.length === 0) {
    console.log(red("\n‚úó No providers configured in manic.config.ts\n"));
    console.log(dim("Add a provider to deploy:"));
    console.log(cyan('\n  import { vercel } from "@manicjs/providers";\n'));
    console.log(dim("  providers: [vercel()]"));
    process.exit(1);
  }

  const providerNames = providers.map((p) => p.name).join(", ");
  console.log(
    `\n${red(bold("‚ñ† MANIC"))} ${dim("deploy")} ‚Üí ${cyan(providerNames)}\n`
  );

  const dist = config.build?.outdir ?? ".manic";
  if (!existsSync(dist)) {
    console.log(dim("‚óè Building first..."));
    await build();
    console.log("");
  }

  const projectName =
    config.app?.name?.toLowerCase().replace(/\s+/g, "-") ?? "manic-app";

  const deployCommands: Record<
    string,
    { configFile: string | null; command: string }
  > = {
    vercel: {
      configFile: "vercel.json",
      command: "bunx vercel deploy",
    },
    cloudflare: {
      configFile: null, // wrangler.toml is generated by the provider build
      command: `bunx wrangler pages deploy dist --project-name ${projectName}`,
    },
    netlify: {
      configFile: "netlify.toml",
      command: "bunx netlify deploy --prod",
    },
  };

  const shouldRun =
    process.argv.includes("--run") || process.argv.includes("-r");

  // Process each provider
  for (const provider of providers) {
    console.log(bold(`\nüì¶ ${provider.name}`));
    console.log(dim("‚îÄ".repeat(40)));

    const deployInfo = deployCommands[provider.name];
    if (!deployInfo) {
      console.log(yellow(`  ‚ö† Unknown provider: ${provider.name}`));
      console.log(dim("  Run the deploy command manually for your platform."));
      continue;
    }

    if (deployInfo.configFile && !existsSync(deployInfo.configFile)) {
      console.log(dim(`  ‚óè Generating ${deployInfo.configFile}...`));

      if (provider.name === "vercel") {
        const vercelConfig = {
          buildCommand: "bun run build",
          installCommand: "bun install",
          framework: null,
        };
        await Bun.write("vercel.json", JSON.stringify(vercelConfig, null, 2));
      } else if (provider.name === "netlify") {
        const docsPath =
          config.swagger !== false ? config.swagger?.path ?? "/docs" : null;
        const netlifyToml = `[build]
  command = "bun run build"
  publish = "dist"
  functions = "netlify/functions"

[functions]
  node_bundler = "none"

# API routes -> serverless function
[[redirects]]
  from = "/api/*"
  to = "/.netlify/functions/api"
  status = 200

${
  docsPath
    ? `# Docs routes -> serverless function
[[redirects]]
  from = "${docsPath}"
  to = "/.netlify/functions/api"
  status = 200

[[redirects]]
  from = "${docsPath}/*"
  to = "/.netlify/functions/api"
  status = 200

`
    : ""
}# SPA fallback
[[redirects]]
  from = "/*"
  to = "/index.html"
  status = 200
`;
        await Bun.write("netlify.toml", netlifyToml);
      }

      console.log(dim(green(`  ‚óè Generated ${deployInfo.configFile}`)));
    }

    console.log(`  ${bold("Command:")} ${green(deployInfo.command)}`);

    if (shouldRun) {
      console.log(dim("\n  ‚óè Running deploy...\n"));
      const proc = Bun.spawn(deployInfo.command.split(" "), {
        stdio: ["inherit", "inherit", "inherit"],
        cwd: process.cwd(),
      });
      await proc.exited;
    }
  }

  if (!shouldRun) {
    console.log(
      dim("\nAdd --run or -r flag to execute the deploy commands automatically.\n")
    );
  }
}
